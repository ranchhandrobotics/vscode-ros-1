{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Visual Studio Code Robot Developer Extensions for ROS 1 The Robot Developer Extensions (RDE) is a set of extensions for Visual Studio Code . This extension provides support for the Legacy Robot Operating System (ROS) 1 runtime, an open-source robotics middleware producted by Open Robotics and supports development on Windows and Linux. NOTE: This extension is rebranded and re-released by Ranch Hand Robotics, owned by the maintainer of the ms-iot VSCode ROS Extension with permission from Microsoft. Features Automatic ROS environment configuration. Allows starting, stopping and viewing the ROS core status. Automatically create catkin_make or catkin build build tasks. Create catkin packages using catkin_create_pkg script or catkin create pkg . Run rosrun and roslaunch Resolve dependencies with rosdep shortcut Syntax highlighting for .msg , .urdf and other ROS files. Automatically add the ROS C++ include and Python import paths. Format C++ using the ROS clang-format style. Preview URDF and Xacro files. Debug a single ROS node (C++ or Python) by [attaching to the process][debug_support-attach]. Debug ROS nodes (C++ or Python) [launched from a .launch file][debug_support-launch].","title":"Home"},{"location":"index.html#visual-studio-code-robot-developer-extensions-for-ros-1","text":"The Robot Developer Extensions (RDE) is a set of extensions for Visual Studio Code . This extension provides support for the Legacy Robot Operating System (ROS) 1 runtime, an open-source robotics middleware producted by Open Robotics and supports development on Windows and Linux. NOTE: This extension is rebranded and re-released by Ranch Hand Robotics, owned by the maintainer of the ms-iot VSCode ROS Extension with permission from Microsoft.","title":"Visual Studio Code Robot Developer Extensions for ROS 1"},{"location":"index.html#features","text":"Automatic ROS environment configuration. Allows starting, stopping and viewing the ROS core status. Automatically create catkin_make or catkin build build tasks. Create catkin packages using catkin_create_pkg script or catkin create pkg . Run rosrun and roslaunch Resolve dependencies with rosdep shortcut Syntax highlighting for .msg , .urdf and other ROS files. Automatically add the ROS C++ include and Python import paths. Format C++ using the ROS clang-format style. Preview URDF and Xacro files. Debug a single ROS node (C++ or Python) by [attaching to the process][debug_support-attach]. Debug ROS nodes (C++ or Python) [launched from a .launch file][debug_support-launch].","title":"Features"},{"location":"configuration.html","text":"ROS Launch Configuration options The ROS Launch configuration block supports the following configuration: Option Description name The name which will be displayed in the VS Code UI launch configuration request launch or attach for launching a ROS launch file, or attaching using the attach UI for Pyton or C++ target the launch file path type must be ros to indicate to VS Code that this is a ROS launch configuration arguments Arguments passed to roslaunch such as map:=/foo.yaml' additionalSOLibSearchPath A semicolon delimited search path for Linux symbols sourceFileMap A mapping of Source files from where Symbols expect and the location you have on disk. launch If specified, a list of executables to just launch, attaching to everything else. e.g. \"launch\": [\"rviz\", \"gz\", \"gzserver\", \"gzclient\"] which prevents attaching a debugger to rviz and gazebo. NOTE: the debugger will ignore file extension: x.py is the same as x.exe. attachDebugger If specified, a list of executables to debug. \"attachDebugger\": [\"my_ros_node\"] will only attach to my_ros_node.exe, my_ros_node.py or my_ros_node. Workspace and Global Settings The ROS extension supports the following global settings, which can be overridden in the workspace. Json Option Setting Name Description ros.distro ROS installation distro to be sourced The Distribution to be sourced. On linux, this cause the extension to look for the ROS setup script in /opt/ros/{distro}/setup.bash . On Windows, c:\\opt\\ros\\{distro}\\setup.bat ros.rosSetupScript ROS workspace setup script. Overrides ros.distro. If specified, this will cause the extension to source this script before generating the launch debugging or ROS terminal environment. This overrides the ros.distro, and can be used to specify user scripts or ROS installs in a different location. ros.isolateEnvironment Specify if the extension should not capture the environment VS Code is running in to pass to child processes. Off by default, This setting will prevent the ROS extension from capturing it's hosting environment in case this would conflict with the ROS environment. Workspace example: \u2514\u2500\u2500 .vscode \u251c\u2500\u2500 launch.json \u251c\u2500\u2500 settings.json \u2514\u2500\u2500 tasks.json settings.json { \"ros.distro\" : \"foxy\" , \"ros.rosSetupScript\" : \"/opt/ros/noetic/install/setup.bash\" , \"ros.isolateEnvironment\" : \"false\" }","title":"Configuration"},{"location":"configuration.html#ros-launch-configuration-options","text":"The ROS Launch configuration block supports the following configuration: Option Description name The name which will be displayed in the VS Code UI launch configuration request launch or attach for launching a ROS launch file, or attaching using the attach UI for Pyton or C++ target the launch file path type must be ros to indicate to VS Code that this is a ROS launch configuration arguments Arguments passed to roslaunch such as map:=/foo.yaml' additionalSOLibSearchPath A semicolon delimited search path for Linux symbols sourceFileMap A mapping of Source files from where Symbols expect and the location you have on disk. launch If specified, a list of executables to just launch, attaching to everything else. e.g. \"launch\": [\"rviz\", \"gz\", \"gzserver\", \"gzclient\"] which prevents attaching a debugger to rviz and gazebo. NOTE: the debugger will ignore file extension: x.py is the same as x.exe. attachDebugger If specified, a list of executables to debug. \"attachDebugger\": [\"my_ros_node\"] will only attach to my_ros_node.exe, my_ros_node.py or my_ros_node.","title":"ROS Launch Configuration options"},{"location":"configuration.html#workspace-and-global-settings","text":"The ROS extension supports the following global settings, which can be overridden in the workspace. Json Option Setting Name Description ros.distro ROS installation distro to be sourced The Distribution to be sourced. On linux, this cause the extension to look for the ROS setup script in /opt/ros/{distro}/setup.bash . On Windows, c:\\opt\\ros\\{distro}\\setup.bat ros.rosSetupScript ROS workspace setup script. Overrides ros.distro. If specified, this will cause the extension to source this script before generating the launch debugging or ROS terminal environment. This overrides the ros.distro, and can be used to specify user scripts or ROS installs in a different location. ros.isolateEnvironment Specify if the extension should not capture the environment VS Code is running in to pass to child processes. Off by default, This setting will prevent the ROS extension from capturing it's hosting environment in case this would conflict with the ROS environment. Workspace example: \u2514\u2500\u2500 .vscode \u251c\u2500\u2500 launch.json \u251c\u2500\u2500 settings.json \u2514\u2500\u2500 tasks.json settings.json { \"ros.distro\" : \"foxy\" , \"ros.rosSetupScript\" : \"/opt/ros/noetic/install/setup.bash\" , \"ros.isolateEnvironment\" : \"false\" }","title":"Workspace and Global Settings"},{"location":"debug-support.html","text":"Debug ROS Nodes One of the key goals of vscode-ros is to provide a streamlined debugging experience for ROS nodes. To achieve this, this extension aims to help developers utilize the debugging capabilities provided by Visual Studio Code. This document covers instructions of how to use such functionalities. Read more about the design and related discussions on the debugging functionalities in our design document . Attach vscode-ros enables a bootstrapped debugging experience for debugging a ROS (Python or C++) node by attaching to the process. To get started, create a ros -type debug configuration with an attach request: (use Ctrl - Space to bring up the autocomplete dropdown) Attaching to a Python node Attaching to a C++ node Launch vscode-ros enables a streamlined debugging experience for debugging a ROS (Python or C++) node in a ROS launch file similar to a native debug flow. To get started, create a ros -type debug configuration with a launch request: Prerequisite There needs to be a running instance of rosmaster . The launch-debug flow provided by vscode-ros will not spawn a rosmaster . Launch and debug Python and C++ nodes Use tasks to automatically build before starting debug session The first thing you need to do is to create build task for your package(s) with enabled debug symbols. In the example below you can see a catkin_make build task that passes additional -DCMAKE_BUILD_TYPE=Debug argument that switches build to use Debug configuration, which is the most suitable configuration for debugging, because it has 0 optimization level and includes debug symbols. Another option is to use -DCMAKE_BUILD_TYPE=RelWithDebInfo that also enables debug symbols, but uses Release settings for everything else and has optimizations enabled. RelWithDebInfo might be a go to build configuration for Windows users in order to avoid slowness of the debug CRT on Windows OS. You can read more about CMAKE_BUILD_TYPE here Note: you might need to remove the old build folder to force rebuild in new configuraiton. { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"make_debug\", \"type\": \"catkin_make\", \"args\": [ \"--directory\", \"${workspaceFolder}\", \"-DCMAKE_BUILD_TYPE=Debug\", // This extra argument enables built with debug symbols ], \"problemMatcher\": [ \"$catkin-gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true }, }, ] } The next step would be to configure .vscode/launch.json and customize preLaunchTask to use make_debug task we created above. { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"ROS: Launch\", \"type\": \"ros\", \"request\": \"launch\", \"target\": \"${workspaceFolder}/launch/some.launch\", // <<< Configure path to your launch file \"preLaunchTask\": \"make_debug\", // <<< This is the task that will run before debugging starts } ] } Use tasks to automatically build and start rosmaster This is current BLOCKED BY VSCode Bug 70283 . This bug will prevent the second debugging session from starting if roscore background task is already running This section continues setup that was described above , so please complete that section and ensure you can build and debug with manually started roscore We are going to define a new task named make_debug_and_core that is going to start both make_debug and roscore: roscore tasks. roscore: roscore is a background task that will continue running even after debuging session is over { \"version\": \"2.0.0\", \"tasks\": [ /// ... `make_debug` task definition as before { \"label\": \"make_debug_and_core\", \"dependsOn\": [ \"make_debug\", \"roscore: roscore\", // This task is provided by vscode-ros ] }, ] } The next step would be to switch preLaunchTask to use make_debug_and_core task we created above. { \"version\": \"0.2.0\", \"configurations\": [ { // ... same as before \"preLaunchTask\": \"make_debug_and_core\", } ] } Note Debugging functionality provided by vscode-ros has dependencies on VS Code\u2019s C++ and Python extensions, and those have dependencies on the version of VS Code. To ensure everything works as expected, please make sure to have everything up-to-date. To debug a C++ executable, please make sure the binary is built with debug symbols (e.g. -DCMAKE_BUILD_TYPE=RelWithDebInfo , read more about CMAKE_BUILD_TYPE here ). To use VS Code's C++ extension with MSVC on Windows, please make sure the VS Code instance is launched from a Visual Studio command prompt.","title":"Debug ROS Nodes"},{"location":"debug-support.html#debug-ros-nodes","text":"One of the key goals of vscode-ros is to provide a streamlined debugging experience for ROS nodes. To achieve this, this extension aims to help developers utilize the debugging capabilities provided by Visual Studio Code. This document covers instructions of how to use such functionalities. Read more about the design and related discussions on the debugging functionalities in our design document .","title":"Debug ROS Nodes"},{"location":"debug-support.html#attach","text":"vscode-ros enables a bootstrapped debugging experience for debugging a ROS (Python or C++) node by attaching to the process. To get started, create a ros -type debug configuration with an attach request: (use Ctrl - Space to bring up the autocomplete dropdown)","title":"Attach"},{"location":"debug-support.html#attaching-to-a-python-node","text":"","title":"Attaching to a Python node"},{"location":"debug-support.html#attaching-to-a-c-node","text":"","title":"Attaching to a C++ node"},{"location":"debug-support.html#launch","text":"vscode-ros enables a streamlined debugging experience for debugging a ROS (Python or C++) node in a ROS launch file similar to a native debug flow. To get started, create a ros -type debug configuration with a launch request:","title":"Launch"},{"location":"debug-support.html#prerequisite","text":"There needs to be a running instance of rosmaster . The launch-debug flow provided by vscode-ros will not spawn a rosmaster .","title":"Prerequisite"},{"location":"debug-support.html#launch-and-debug-python-and-c-nodes","text":"","title":"Launch and debug Python and C++ nodes"},{"location":"debug-support.html#use-tasks-to-automatically-build-before-starting-debug-session","text":"The first thing you need to do is to create build task for your package(s) with enabled debug symbols. In the example below you can see a catkin_make build task that passes additional -DCMAKE_BUILD_TYPE=Debug argument that switches build to use Debug configuration, which is the most suitable configuration for debugging, because it has 0 optimization level and includes debug symbols. Another option is to use -DCMAKE_BUILD_TYPE=RelWithDebInfo that also enables debug symbols, but uses Release settings for everything else and has optimizations enabled. RelWithDebInfo might be a go to build configuration for Windows users in order to avoid slowness of the debug CRT on Windows OS. You can read more about CMAKE_BUILD_TYPE here Note: you might need to remove the old build folder to force rebuild in new configuraiton. { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"make_debug\", \"type\": \"catkin_make\", \"args\": [ \"--directory\", \"${workspaceFolder}\", \"-DCMAKE_BUILD_TYPE=Debug\", // This extra argument enables built with debug symbols ], \"problemMatcher\": [ \"$catkin-gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true }, }, ] } The next step would be to configure .vscode/launch.json and customize preLaunchTask to use make_debug task we created above. { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"ROS: Launch\", \"type\": \"ros\", \"request\": \"launch\", \"target\": \"${workspaceFolder}/launch/some.launch\", // <<< Configure path to your launch file \"preLaunchTask\": \"make_debug\", // <<< This is the task that will run before debugging starts } ] }","title":"Use tasks to automatically build before starting debug session"},{"location":"debug-support.html#use-tasks-to-automatically-build-and-start-rosmaster","text":"This is current BLOCKED BY VSCode Bug 70283 . This bug will prevent the second debugging session from starting if roscore background task is already running This section continues setup that was described above , so please complete that section and ensure you can build and debug with manually started roscore We are going to define a new task named make_debug_and_core that is going to start both make_debug and roscore: roscore tasks. roscore: roscore is a background task that will continue running even after debuging session is over { \"version\": \"2.0.0\", \"tasks\": [ /// ... `make_debug` task definition as before { \"label\": \"make_debug_and_core\", \"dependsOn\": [ \"make_debug\", \"roscore: roscore\", // This task is provided by vscode-ros ] }, ] } The next step would be to switch preLaunchTask to use make_debug_and_core task we created above. { \"version\": \"0.2.0\", \"configurations\": [ { // ... same as before \"preLaunchTask\": \"make_debug_and_core\", } ] }","title":"Use tasks to automatically build and start rosmaster"},{"location":"debug-support.html#note","text":"Debugging functionality provided by vscode-ros has dependencies on VS Code\u2019s C++ and Python extensions, and those have dependencies on the version of VS Code. To ensure everything works as expected, please make sure to have everything up-to-date. To debug a C++ executable, please make sure the binary is built with debug symbols (e.g. -DCMAKE_BUILD_TYPE=RelWithDebInfo , read more about CMAKE_BUILD_TYPE here ). To use VS Code's C++ extension with MSVC on Windows, please make sure the VS Code instance is launched from a Visual Studio command prompt.","title":"Note"},{"location":"launchdebugging.html","text":"Launch Debugging The Visual Studio Code extension for ROS supports launch debugging for ROS nodes written in Python and C++. The ROS node or nodes to be debugged must be placed in a ROS launch file with the extension .launch . Automatic creation of a launch.json with ROS Launch support .vscode/launch.json is a file which defines a debug launch configuration within VS Code. To create a .vscode/launch.json with ROS debugging support C++ or Python file is selected, vscode uses the selected file to seed the launch creation UI. Click the Run and Debug tab on the left sidebar Select the link to create a .vscode/launch.json file. VS Code will drop down from the command pallet with a list of options, which includes 'ROS'. Select this option. In the next dialog, type the name of the ROS package containing a launch file you'd like to debug. Then find the launch file. Once this is created, you can use the play button in the title bar, or the \"start debugging\" accelerator key, or from the command palle (CTRL-SHIFT-P), select Debug: Start Debugging . NOTE: Other VS Code extensions may interfere with the selection list. If you do not see ROS in the first drop down list, you'll need to create a new file called .vscode/launch.json , then use the manual option described below. Manually adding a launch file to an existing launch.json If you have an existing launch.json file (or if there is an extension conflict as mentioned above), you can manually add a launch configuration by adding a new block like this. { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS: Launch my file\" , \"request\" : \"launch\" , \"target\" : \"<full path to your launch.py or launch file>\" , \"launch\" : [ \"rviz\" , \"gz\" , \"gzserver\" , \"gzclient\" ], \"type\" : \"ros\" } ] } Be sure to include the full path to your launch file, including file extension.","title":"Launchdebugging"},{"location":"launchdebugging.html#launch-debugging","text":"The Visual Studio Code extension for ROS supports launch debugging for ROS nodes written in Python and C++. The ROS node or nodes to be debugged must be placed in a ROS launch file with the extension .launch .","title":"Launch Debugging"},{"location":"launchdebugging.html#automatic-creation-of-a-launchjson-with-ros-launch-support","text":".vscode/launch.json is a file which defines a debug launch configuration within VS Code. To create a .vscode/launch.json with ROS debugging support C++ or Python file is selected, vscode uses the selected file to seed the launch creation UI. Click the Run and Debug tab on the left sidebar Select the link to create a .vscode/launch.json file. VS Code will drop down from the command pallet with a list of options, which includes 'ROS'. Select this option. In the next dialog, type the name of the ROS package containing a launch file you'd like to debug. Then find the launch file. Once this is created, you can use the play button in the title bar, or the \"start debugging\" accelerator key, or from the command palle (CTRL-SHIFT-P), select Debug: Start Debugging . NOTE: Other VS Code extensions may interfere with the selection list. If you do not see ROS in the first drop down list, you'll need to create a new file called .vscode/launch.json , then use the manual option described below.","title":"Automatic creation of a launch.json with ROS Launch support"},{"location":"launchdebugging.html#manually-adding-a-launch-file-to-an-existing-launchjson","text":"If you have an existing launch.json file (or if there is an extension conflict as mentioned above), you can manually add a launch configuration by adding a new block like this. { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"ROS: Launch my file\" , \"request\" : \"launch\" , \"target\" : \"<full path to your launch.py or launch file>\" , \"launch\" : [ \"rviz\" , \"gz\" , \"gzserver\" , \"gzclient\" ], \"type\" : \"ros\" } ] } Be sure to include the full path to your launch file, including file extension.","title":"Manually adding a launch file to an existing launch.json"},{"location":"tutorials.html","text":"Tutorials and Walkthroughs Name Description Attaching to a running ROS Node Learn how to attach VS Code to a running ROS node Debugging all ROS Nodes in a launch file Learn how to set up VS Code to debug the nodes in a ROS Launch file ROSCON 2019 ROS Extension Talk Video Walkthrough of VS Code from ROSCon 2019 Deep Dive - Episode 0 About the VS Code ROS extension @ a Polyhobbyist Deep Dive - Episode 1 Installing on Windows & WSL @ a Polyhobbyist Deep Dive - Episode 2 Installing on Linux @ a Polyhobbyist Deep Dive - Episode 3 General Usage with ROS1 @ a Polyhobbyist Deep Dive - Episode 4 General Usage with ROS2 @ a Polyhobbyist Deep Dive - Episode 5 Debugging Python @ a Polyhobbyist Deep Dive - Episode 6 Debugging C++ @ a Polyhobbyist Deep Dive - Episode 7 Using with SSH @ a Polyhobbyist Deep Dive - Episode 8 Using with with Containers @ a Polyhobbyist","title":"Tutorials"},{"location":"tutorials.html#tutorials-and-walkthroughs","text":"Name Description Attaching to a running ROS Node Learn how to attach VS Code to a running ROS node Debugging all ROS Nodes in a launch file Learn how to set up VS Code to debug the nodes in a ROS Launch file ROSCON 2019 ROS Extension Talk Video Walkthrough of VS Code from ROSCon 2019 Deep Dive - Episode 0 About the VS Code ROS extension @ a Polyhobbyist Deep Dive - Episode 1 Installing on Windows & WSL @ a Polyhobbyist Deep Dive - Episode 2 Installing on Linux @ a Polyhobbyist Deep Dive - Episode 3 General Usage with ROS1 @ a Polyhobbyist Deep Dive - Episode 4 General Usage with ROS2 @ a Polyhobbyist Deep Dive - Episode 5 Debugging Python @ a Polyhobbyist Deep Dive - Episode 6 Debugging C++ @ a Polyhobbyist Deep Dive - Episode 7 Using with SSH @ a Polyhobbyist Deep Dive - Episode 8 Using with with Containers @ a Polyhobbyist","title":"Tutorials and Walkthroughs"},{"location":"usage.html","text":"Commands You can access the following commands from the Visual Studio Code command pallet , typically accessed by pressing ctrl + shift + p and typing the command name you'd like to use from the table below. Name Description ROS: Create Catkin Package Create a catkin package. You can right click on a folder in the explorer to create it in a specific location. ROS: Create Terminal Create a terminal with the ROS environment. ROS: Show Status Open a detail view showing ROS core runtime status. ROS: Start Start ROS core. ROS: Stop Terminate ROS core. ROS: Update C++ Properties Update the C++ IntelliSense configuration to include ROS and your ROS components. ROS: Update Python Path Update the Python IntelliSense configuration to include ROS. ROS: Preview URDF Preview URDF and Xacro files. The display will update after the root URDF changes are saved. ROS: Install ROS Dependencies for this workspace using rosdep Shortcut for rosdep install --from-paths src --ignore-src -r -y .","title":"Usage"},{"location":"usage.html#commands","text":"You can access the following commands from the Visual Studio Code command pallet , typically accessed by pressing ctrl + shift + p and typing the command name you'd like to use from the table below. Name Description ROS: Create Catkin Package Create a catkin package. You can right click on a folder in the explorer to create it in a specific location. ROS: Create Terminal Create a terminal with the ROS environment. ROS: Show Status Open a detail view showing ROS core runtime status. ROS: Start Start ROS core. ROS: Stop Terminate ROS core. ROS: Update C++ Properties Update the C++ IntelliSense configuration to include ROS and your ROS components. ROS: Update Python Path Update the Python IntelliSense configuration to include ROS. ROS: Preview URDF Preview URDF and Xacro files. The display will update after the root URDF changes are saved. ROS: Install ROS Dependencies for this workspace using rosdep Shortcut for rosdep install --from-paths src --ignore-src -r -y .","title":"Commands"},{"location":"spec/debug-ros-nodes.html","text":"Debug ROS nodes with vscode-ros Debugging is one of the most important and needed feature of a developer's toolkit when it comes to software development. To debug ROS nodes launched by roslaunch , ROS wiki suggests using the launch-prefix attribute defined in a .launch launch file with debugger commands like this: launch-prefix usage gdb -ex run --args run node in gdb in the same xterm valgrind run node in valgrind Currently, this approach only provides limited debugger support to roscpp nodes. Goals enable attaching into a local C++ or Python process launched through roslaunch to debug that process enable debugging C++ and Python nodes specified in a .launch file at entry Non-goals Language-specific debugging capabilities including: complicated debugging scenarios like debugging a remote process We would want to utilize existing language-specific tools for C++ and Python : Debugging in Visual Studio Code Typically, to start a debugging sessions, a debug configuration should be created in launch.json first. After that, the newly created configuration could be selected and executed by pressing the green arrow or the F5 key. What happens afterwards gets handled by 2 processes: the running Visual Studio Code instance (this is the running context of all extensions) the debug adapter instance (for each language) A debug configuration first gets resolved by a registered debug configuration provider in VS Code's context. Afterwards, a debug request gets sent to the extension\u2019s debug adapter, which actually handles the debugging process. However, the debug adapter is a separate process from the VS Code process, so no vscode APIs could be called from there. In our scenario, we need to do everything in the extension context to utilize the functionalities provided by other extensions. Ideally, the workflow should be as simple as possible: the user creates a ros -type debug configuration our extension resolves the configuration our extension generates debug configuration for C++ or/and Python extensions As illustrated in the above flow chart, we would also need a stub debug adapter . Attach Our goal for attach-debug is to provide a way to debug a ROS node while not changing anything in an existing flow. This means when the user executes a .launch file with roslaunch just like before, he/she could use vscode-ros to easily start an attach-debug session to debug a running ROS node process. All attach-debug configurations are propagated to language-specific extensions. Attach into a C++ process Just like using Visual Studio or windbg, attaching into a running C++ process could be achieved with vscode-cpptools easily. Our extension automatically chooses cppvsdbg for MSVC debugger when it's running on Windows, and cppdbg for gdb-based debugger otherwise. Attach into a Python process Our extension uses ptvsd to enable debugging Python scripts. Generally, a Python script needs to be launched through the ptvsd module to be able to be debugged: python -m ptvsd \u2013host <host> --port <port> <script> Once a script is launched like this, a Python attach session could be launched inside VS Code to attach to the ptvsd server running inside the process. However, Python processes launched by ROS tools ( rosrun and roslaunch ) are usually launched natively. To debug a Python process without a running ptvsd instance, a ptvsd instance needs to be injected into the process first with the --pid <pid> flag. Therefore, for normal Python processes in ROS, the workflow would be: get the PID of the Python process (we reuse the processPicker module from vscode-cpptools ) inject ptvsd using API exposed by vscode-python (this avoids potential ptvsd version mismatch) start a Python-attach debug session with vscode-python To avoid potential version mismatch between the ptvsd module used by the Python extension and the one to be injected into the Python process, we use the API exposed by vscode-python to ensure the same version across processes. Example for attach { \"configurations\" : [ { \"name\" : \"ROS: Attach\" , \"type\" : \"ros\" , \"request\" : \"attach\" }, { \"name\" : \"ROS: Attach to Python\" , \"type\" : \"ros\" , \"request\" : \"attach\" , \"runtime\" : \"Python\" } ] } Note on attach-debug Microsoft's VS Code extensions for C++ and Python provide flexible mechanisms of attaching into a C++ or Python process. This extension only aims to enable a basic and generic attach-debug flow. Please use language-specific extensions for any specific debugging requirements including: specifying symbolSearchPath or miDebuggerPath for C++ debugging attaching to and debugging a remote process Launch Our goal for launch-debug is to mimic the experience of debugging a single program in VS Code. When a .launch file is launched in debug mode, we want to launch all the ROS nodes defined in it in debug mode at the same time. Similar to attach-debug, we want to utilize all the language-specific debugging functionalities provided by vscode-python and vscode-cpptools . From another perspective, we aim to translate launch configurations in a .launch file into debug configurations for VS Code that will be executed all at the same time. To do this, we use the command line functionality of roslaunch to extract launch requests from a .launch file: get parameters defined in the .launch file with roslaunch --dump-params <launch-file> load parameters with rosparam load get the nodes defined in the .launch files with roslaunch --nodes <launch-file> get launch requests for each node with roslaunch --args <node> <launch-file> TODO [ ] #122 support language-specific configurations in debug configuration Limitations when using the --args flag to get launch requests from the .launch file, environment configurations would be expressed as inline env-set commands: someenv = somevalue node arg: = value which would require extra (reverse) parsing of the command line. This could be avoided if roslaunch gets updated . with the current implementation, all nodes in a .launch file, instead of only some specified ones , will be launched in debug mode. Potentially, when too many debug sessions are launched at the same time, it would be painful to terminate them one by one. To work around this, use more than 1 .launch files and use one of them specifically for a limited number of nodes that need to be debugged. currently, when attempting to start multiple Python-launch debug sessions at once, only 1 of them could be connected. For this reason, it is limited to have only 1 Python node in the launch file for now. This is related to issues #7269 and #6017 in vscode-python . Example for launch { \"configurations\" : [ { \"name\" : \"ROS: Launch\" , \"type\" : \"ros\" , \"request\" : \"launch\" , \"target\" : \"C:\\\\ros\\\\project_ws\\\\src\\\\project\\\\launch\\\\sample.launch\" }, { \"name\" : \"ROS: Launch\" , \"type\" : \"ros\" , \"request\" : \"launch\" , \"target\" : \"C:\\\\ros\\\\project_ws\\\\src\\\\project\\\\launch\\\\sample.launch\" , \"stopOnEntry\" : true } ] } ROS2 support This extension currently does not support the launch tool for ROS2 . Support for ros2/launch will be added once the launcher becomes stabilized. Appendix Why no launch-prefix support for rospy The ROS Wiki suggested launch-prefix attribute is only supported for roscpp nodes, and this is our take on why it is not for rospy too. All roscpp nodes are compiled C++ binaries (executables), so a roscpp node called talker could be launched directly from the command line like this: ./talker and launching it with a debugger is straightforward: gdb -ex run --args ./talker valgrind ./talker At the same time, rospy nodes are Python scripts made executable (on Linux) by adding a shebang line , the actual executable is the Python interpreter: ./talker # when talker.py has #!/usr/bin/python as the shebang line, the above line just means /usr/bin/python ./talker Typically, to debug a Python script, one would need to use either pdb or ptvsd : python -m pdb ./talker.py # ptvsd only starts a debugging server inside the process python -m ptvsd --host localhost --port 5678 --wait ./talker.py To have these as the final commands, everything before ./talker.py need to be part of the shebang line. However, that would be a bad choice since generally the script would/should not be launched in debug mode. For this reason, there is no place to insert launch-prefix flags for rospy nodes. This is a good example why it is suggested to keep the .py filename extension, and create separate a separate console script . Why is a stub debug adapter needed As illustrated in the flow charts above, a stub debug adapter that self-terminates immediately is still needed by vscode-ros to handle debug requests. These debug requests are generated from the ros -type debug configurations. When debug configurations are executed, they are resolved into debug requests and then sent to corresponding debug adapters. It would lead to errors generated in VS Code if no debug adapter is there to handle the debug requests. What about adding a debug attribute to the node element in roslaunch Potentially, it could be helpful if the user could add a debug=True attribute (just like launch-prefix ) in the .launch file to debug specific node(s). However, since this means changing XML specification for ROS launch files, it would require all launchers (including roslaunch ) to understand and consume this flag. This is not preferred since roslaunch does not support launching nodes in debug mode. What about an updated roslaunch Ideally, roslaunch could be updated to support a --debug flag. When this flag is added, roslaunch will not start any of the ROS nodes, but instead print out the launch requests in an easy-to-parse format (e.g. JSON): parameters to be set for the launch request environment configurations for each node launch commands for each node","title":"Debug ROS nodes with vscode-ros"},{"location":"spec/debug-ros-nodes.html#debug-ros-nodes-with-vscode-ros","text":"Debugging is one of the most important and needed feature of a developer's toolkit when it comes to software development. To debug ROS nodes launched by roslaunch , ROS wiki suggests using the launch-prefix attribute defined in a .launch launch file with debugger commands like this: launch-prefix usage gdb -ex run --args run node in gdb in the same xterm valgrind run node in valgrind Currently, this approach only provides limited debugger support to roscpp nodes.","title":"Debug ROS nodes with vscode-ros"},{"location":"spec/debug-ros-nodes.html#goals","text":"enable attaching into a local C++ or Python process launched through roslaunch to debug that process enable debugging C++ and Python nodes specified in a .launch file at entry","title":"Goals"},{"location":"spec/debug-ros-nodes.html#non-goals","text":"Language-specific debugging capabilities including: complicated debugging scenarios like debugging a remote process We would want to utilize existing language-specific tools for C++ and Python :","title":"Non-goals"},{"location":"spec/debug-ros-nodes.html#debugging-in-visual-studio-code","text":"Typically, to start a debugging sessions, a debug configuration should be created in launch.json first. After that, the newly created configuration could be selected and executed by pressing the green arrow or the F5 key. What happens afterwards gets handled by 2 processes: the running Visual Studio Code instance (this is the running context of all extensions) the debug adapter instance (for each language) A debug configuration first gets resolved by a registered debug configuration provider in VS Code's context. Afterwards, a debug request gets sent to the extension\u2019s debug adapter, which actually handles the debugging process. However, the debug adapter is a separate process from the VS Code process, so no vscode APIs could be called from there. In our scenario, we need to do everything in the extension context to utilize the functionalities provided by other extensions. Ideally, the workflow should be as simple as possible: the user creates a ros -type debug configuration our extension resolves the configuration our extension generates debug configuration for C++ or/and Python extensions As illustrated in the above flow chart, we would also need a stub debug adapter .","title":"Debugging in Visual Studio Code"},{"location":"spec/debug-ros-nodes.html#attach","text":"Our goal for attach-debug is to provide a way to debug a ROS node while not changing anything in an existing flow. This means when the user executes a .launch file with roslaunch just like before, he/she could use vscode-ros to easily start an attach-debug session to debug a running ROS node process. All attach-debug configurations are propagated to language-specific extensions.","title":"Attach"},{"location":"spec/debug-ros-nodes.html#attach-into-a-c-process","text":"Just like using Visual Studio or windbg, attaching into a running C++ process could be achieved with vscode-cpptools easily. Our extension automatically chooses cppvsdbg for MSVC debugger when it's running on Windows, and cppdbg for gdb-based debugger otherwise.","title":"Attach into a C++ process"},{"location":"spec/debug-ros-nodes.html#attach-into-a-python-process","text":"Our extension uses ptvsd to enable debugging Python scripts. Generally, a Python script needs to be launched through the ptvsd module to be able to be debugged: python -m ptvsd \u2013host <host> --port <port> <script> Once a script is launched like this, a Python attach session could be launched inside VS Code to attach to the ptvsd server running inside the process. However, Python processes launched by ROS tools ( rosrun and roslaunch ) are usually launched natively. To debug a Python process without a running ptvsd instance, a ptvsd instance needs to be injected into the process first with the --pid <pid> flag. Therefore, for normal Python processes in ROS, the workflow would be: get the PID of the Python process (we reuse the processPicker module from vscode-cpptools ) inject ptvsd using API exposed by vscode-python (this avoids potential ptvsd version mismatch) start a Python-attach debug session with vscode-python To avoid potential version mismatch between the ptvsd module used by the Python extension and the one to be injected into the Python process, we use the API exposed by vscode-python to ensure the same version across processes.","title":"Attach into a Python process"},{"location":"spec/debug-ros-nodes.html#example-for-attach","text":"{ \"configurations\" : [ { \"name\" : \"ROS: Attach\" , \"type\" : \"ros\" , \"request\" : \"attach\" }, { \"name\" : \"ROS: Attach to Python\" , \"type\" : \"ros\" , \"request\" : \"attach\" , \"runtime\" : \"Python\" } ] }","title":"Example for attach"},{"location":"spec/debug-ros-nodes.html#note-on-attach-debug","text":"Microsoft's VS Code extensions for C++ and Python provide flexible mechanisms of attaching into a C++ or Python process. This extension only aims to enable a basic and generic attach-debug flow. Please use language-specific extensions for any specific debugging requirements including: specifying symbolSearchPath or miDebuggerPath for C++ debugging attaching to and debugging a remote process","title":"Note on attach-debug"},{"location":"spec/debug-ros-nodes.html#launch","text":"Our goal for launch-debug is to mimic the experience of debugging a single program in VS Code. When a .launch file is launched in debug mode, we want to launch all the ROS nodes defined in it in debug mode at the same time. Similar to attach-debug, we want to utilize all the language-specific debugging functionalities provided by vscode-python and vscode-cpptools . From another perspective, we aim to translate launch configurations in a .launch file into debug configurations for VS Code that will be executed all at the same time. To do this, we use the command line functionality of roslaunch to extract launch requests from a .launch file: get parameters defined in the .launch file with roslaunch --dump-params <launch-file> load parameters with rosparam load get the nodes defined in the .launch files with roslaunch --nodes <launch-file> get launch requests for each node with roslaunch --args <node> <launch-file>","title":"Launch"},{"location":"spec/debug-ros-nodes.html#todo","text":"[ ] #122 support language-specific configurations in debug configuration","title":"TODO"},{"location":"spec/debug-ros-nodes.html#limitations","text":"when using the --args flag to get launch requests from the .launch file, environment configurations would be expressed as inline env-set commands: someenv = somevalue node arg: = value which would require extra (reverse) parsing of the command line. This could be avoided if roslaunch gets updated . with the current implementation, all nodes in a .launch file, instead of only some specified ones , will be launched in debug mode. Potentially, when too many debug sessions are launched at the same time, it would be painful to terminate them one by one. To work around this, use more than 1 .launch files and use one of them specifically for a limited number of nodes that need to be debugged. currently, when attempting to start multiple Python-launch debug sessions at once, only 1 of them could be connected. For this reason, it is limited to have only 1 Python node in the launch file for now. This is related to issues #7269 and #6017 in vscode-python .","title":"Limitations"},{"location":"spec/debug-ros-nodes.html#example-for-launch","text":"{ \"configurations\" : [ { \"name\" : \"ROS: Launch\" , \"type\" : \"ros\" , \"request\" : \"launch\" , \"target\" : \"C:\\\\ros\\\\project_ws\\\\src\\\\project\\\\launch\\\\sample.launch\" }, { \"name\" : \"ROS: Launch\" , \"type\" : \"ros\" , \"request\" : \"launch\" , \"target\" : \"C:\\\\ros\\\\project_ws\\\\src\\\\project\\\\launch\\\\sample.launch\" , \"stopOnEntry\" : true } ] }","title":"Example for launch"},{"location":"spec/debug-ros-nodes.html#ros2-support","text":"This extension currently does not support the launch tool for ROS2 . Support for ros2/launch will be added once the launcher becomes stabilized.","title":"ROS2 support"},{"location":"spec/debug-ros-nodes.html#appendix","text":"","title":"Appendix"},{"location":"spec/debug-ros-nodes.html#why-no-launch-prefix-support-for-rospy","text":"The ROS Wiki suggested launch-prefix attribute is only supported for roscpp nodes, and this is our take on why it is not for rospy too. All roscpp nodes are compiled C++ binaries (executables), so a roscpp node called talker could be launched directly from the command line like this: ./talker and launching it with a debugger is straightforward: gdb -ex run --args ./talker valgrind ./talker At the same time, rospy nodes are Python scripts made executable (on Linux) by adding a shebang line , the actual executable is the Python interpreter: ./talker # when talker.py has #!/usr/bin/python as the shebang line, the above line just means /usr/bin/python ./talker Typically, to debug a Python script, one would need to use either pdb or ptvsd : python -m pdb ./talker.py # ptvsd only starts a debugging server inside the process python -m ptvsd --host localhost --port 5678 --wait ./talker.py To have these as the final commands, everything before ./talker.py need to be part of the shebang line. However, that would be a bad choice since generally the script would/should not be launched in debug mode. For this reason, there is no place to insert launch-prefix flags for rospy nodes. This is a good example why it is suggested to keep the .py filename extension, and create separate a separate console script .","title":"Why no launch-prefix support for rospy"},{"location":"spec/debug-ros-nodes.html#why-is-a-stub-debug-adapter-needed","text":"As illustrated in the flow charts above, a stub debug adapter that self-terminates immediately is still needed by vscode-ros to handle debug requests. These debug requests are generated from the ros -type debug configurations. When debug configurations are executed, they are resolved into debug requests and then sent to corresponding debug adapters. It would lead to errors generated in VS Code if no debug adapter is there to handle the debug requests.","title":"Why is a stub debug adapter needed"},{"location":"spec/debug-ros-nodes.html#what-about-adding-a-debug-attribute-to-the-node-element-in-roslaunch","text":"Potentially, it could be helpful if the user could add a debug=True attribute (just like launch-prefix ) in the .launch file to debug specific node(s). However, since this means changing XML specification for ROS launch files, it would require all launchers (including roslaunch ) to understand and consume this flag. This is not preferred since roslaunch does not support launching nodes in debug mode.","title":"What about adding a debug attribute to the node element in roslaunch"},{"location":"spec/debug-ros-nodes.html#what-about-an-updated-roslaunch","text":"Ideally, roslaunch could be updated to support a --debug flag. When this flag is added, roslaunch will not start any of the ROS nodes, but instead print out the launch requests in an easy-to-parse format (e.g. JSON): parameters to be set for the launch request environment configurations for each node launch commands for each node","title":"What about an updated roslaunch"}]}